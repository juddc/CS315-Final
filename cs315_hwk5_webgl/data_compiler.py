#!/usr/bin/env python
"""
This script 'compiles' multiple text files into a single Javascript file
containing strings that represent each input file.

The goal is to store shader and model data in individual, easily editable
files, but still have the convenience of being able to load one big JavaScript
file and not need to worry about where those files come from.

To configure this script, just edit the OUTPUT_FILE and INPUT_FILES variables
at the top.
"""
import sys
import os

# save path
OUTPUT_FILE = os.path.join("gameJS", "GameData.js")

# files that get compiled into javascript. text files only.
INPUT_DIRECTORY = "gameData"

# Strip comments, blank lines, and leading/trailing whitespace from input files
# This should be set to False if debugging GLSL
STRIP_INPUT_DATA = True


"""
Converts a text file into a javascript dict entry
"""
def convertFile(fileName):
    output = []

    if not os.path.exists(fileName):
        raise IOError("Could not get file data for '%s'. File does not exist." % fileName)

    fileData = open(fileName, 'r')
    for line in fileData:
        if STRIP_INPUT_DATA:
            # skip blank lines
            if len(line.strip()) == 0:
                continue

            # strip comments from GLSL files
            if fileName.endswith(".glsl"):
                lineData = line.split("//")
                output.append('"%s\\n"' % lineData[0].strip())

            else:
                # strip comments from OBJ files
                if fileName.endswith(".obj") and line.strip().startswith("#"):
                    continue

                output.append('"%s\\n"' % line.strip())
        
        else:
            line = line.replace("\n", "\\n")
            line = line.replace("\r", "\\r")
            line = line.replace("\t", "\\t")
            output.append('"%s"' % line)

    # get rid of the open file handle
    fileData.close()

    # make sure an empty file wont break the resulting output
    if len(output) == 0:
        output.append('""')

    # figure out what the javascript dict key should be
    shortName = os.path.basename(fileName)
    assert len(shortName) > 0

    # combine the file's output into a javascript dict entry that will result in one big string
    return "'%s': [\n\t%s].join(\"\")," % (shortName, ",\n\t".join(output))



"""
Adds a JSON file without converting it
"""
def convertJSONFile(fileName):
    output = []

    if not os.path.exists(fileName):
        raise IOError("Could not get file data for '%s'. File does not exist." % fileName)

    fileData = open(fileName, 'r')
    for line in fileData:
        output.append(line)

    fileData.close()

    if len(output) == 0:
        output.append("")

    shortName = os.path.basename(fileName)
    assert len(shortName) > 0

    return "'%s': %s\n," % (shortName, "".join(output))



"""
Simply writes a string to a file.
Replaces the original file's contents if it had any
"""
def saveToFile(data, fileName):
    fp = open(fileName, 'w')
    fp.write(data)
    fp.close()


"""
Returns a javascript dictionary containing all input files (as a string)
"""
def compileData(inputFiles):
    # output data list. each list item is a line in the output file.
    output = [
        # Output file header
        "// This file is autogenerated. Please do not edit it, your changes will be lost.",
    ]

    # List all input files in the header for easy readability
    output.append("// This script contains the following files:")
    for fileName in inputFiles:
        output.append("// - %s" % fileName)

    # start the javascript dict
    output.append("var DATA = {\n")

    # generate output and tack that onto the file
    for fileName in inputFiles:
        print "Loading %s" % fileName
        try:
            if (fileName.endswith(".json")):
                fileData = convertJSONFile(fileName)
            else:
                fileData = convertFile(fileName)
        except IOError, e:
            print "ERROR: %s" % e
            fileData = "'%s':\n\t\"\"," % fileName
        output.append(fileData)

    # close the javascript dict
    output.append("\n};\n")

    # add function to test if the DATA object has a particular file
    output.append("""
DATA.hasFile = function(fileName) {
    return this.hasOwnProperty(fileName);
}
""")

    # add function to get a list of all files
    output.append("""
DATA.getFileList = function() {
    var keys = [];
    for (var key in DATA) {
        if (DATA.hasFile(key) && key != \"hasFile\" && key != \"getFileList\") {
            keys.push(key);
        }
    }
    return keys;
}
""")

    return "\n".join(output)



if __name__ == "__main__":
    # get rid of first "argument"
    args = sys.argv[1:]

    inputDir = None
    outputFile = None

    # default to values at the top of this file
    if len(args) == 0:
        inputDir = INPUT_DIRECTORY
        outputFile = OUTPUT_FILE

    elif len(args) == 1 or len(args) > 2:
        print "Syntax is:\n> data_compiler.py inputDirectoryName outFile.js"

    elif len(args) == 2:
        inputDir = args[0]
        outputFile = args[1]

    if inputDir is not None and outputFile is not None:
        print "Input directory: %s" % inputDir
        print "Output file: %s\n" % outputFile

        # make file list
        inputFiles = [ os.path.join(inputDir, fileName) for fileName in os.listdir(inputDir) ]
        
        # compile
        data = compileData(inputFiles)
    
        # save
        print "\nSaving to %s" % outputFile
        saveToFile(data, outputFile)

